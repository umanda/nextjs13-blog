// node/array-helpers.ts
function isIn(value, array) {
  return array.includes(value);
}
function isTypeIn(object, array) {
  if (!object.type)
    return false;
  return array.includes(object.type);
}

// node/ensure-extension-dirs.ts
import fse from "fs-extra";
import path from "path";

// node/pluralize.ts
function pluralize(str) {
  return `${str}s`;
}
function depluralize(str) {
  return str.slice(0, -1);
}

// node/ensure-extension-dirs.ts
async function ensureExtensionDirs(extensionsPath, types) {
  for (const extensionType of types) {
    const dirPath = path.resolve(extensionsPath, pluralize(extensionType));
    try {
      await fse.ensureDir(dirPath);
    } catch {
      throw new Error(`Extension folder "${dirPath}" couldn't be opened`);
    }
  }
}

// node/generate-extensions-entrypoint.ts
import { APP_EXTENSION_TYPES, HYBRID_EXTENSION_TYPES } from "@directus/constants";
import path3 from "path";

// node/path-to-relative-url.ts
import path2 from "path";
function pathToRelativeUrl(filePath, root = ".") {
  return path2.relative(root, filePath).split(path2.sep).join(path2.posix.sep);
}

// node/generate-extensions-entrypoint.ts
function generateExtensionsEntrypoint(extensions) {
  const appOrHybridExtensions = extensions.filter(
    (extension) => isIn(extension.type, [...APP_EXTENSION_TYPES, ...HYBRID_EXTENSION_TYPES])
  );
  const bundleExtensions = extensions.filter(
    (extension) => extension.type === "bundle" && extension.entries.some((entry) => isIn(entry.type, [...APP_EXTENSION_TYPES, ...HYBRID_EXTENSION_TYPES]))
  );
  const appOrHybridExtensionImports = [...APP_EXTENSION_TYPES, ...HYBRID_EXTENSION_TYPES].flatMap(
    (type) => appOrHybridExtensions.filter((extension) => extension.type === type).map(
      (extension, i) => `import ${type}${i} from './${pathToRelativeUrl(
        path3.resolve(
          extension.path,
          isTypeIn(extension, HYBRID_EXTENSION_TYPES) ? extension.entrypoint.app : extension.entrypoint
        )
      )}';`
    )
  );
  const bundleExtensionImports = bundleExtensions.map(
    (extension, i) => `import {${[...APP_EXTENSION_TYPES, ...HYBRID_EXTENSION_TYPES].filter((type) => extension.entries.some((entry) => entry.type === type)).map((type) => `${pluralize(type)} as ${type}Bundle${i}`).join(",")}} from './${pathToRelativeUrl(path3.resolve(extension.path, extension.entrypoint.app))}';`
  );
  const extensionExports = [...APP_EXTENSION_TYPES, ...HYBRID_EXTENSION_TYPES].map(
    (type) => `export const ${pluralize(type)} = [${appOrHybridExtensions.filter((extension) => extension.type === type).map((_, i) => `${type}${i}`).concat(
      bundleExtensions.map(
        (extension, i) => extension.entries.some((entry) => entry.type === type) ? `...${type}Bundle${i}` : null
      ).filter((e) => e !== null)
    ).join(",")}];`
  );
  return `${appOrHybridExtensionImports.join("")}${bundleExtensionImports.join("")}${extensionExports.join("")}`;
}

// node/get-extensions.ts
import {
  EXTENSION_NAME_REGEX,
  EXTENSION_PKG_KEY,
  HYBRID_EXTENSION_TYPES as HYBRID_EXTENSION_TYPES2,
  NESTED_EXTENSION_TYPES,
  ExtensionManifest
} from "@directus/constants";
import fse3 from "fs-extra";
import path6 from "path";

// node/list-folders.ts
import path4 from "path";
import fse2 from "fs-extra";
async function listFolders(location) {
  const fullPath = path4.resolve(location);
  const files = await fse2.readdir(fullPath);
  const directories = [];
  for (const file of files) {
    const filePath = path4.join(fullPath, file);
    const stats = await fse2.stat(filePath);
    if (stats.isDirectory()) {
      directories.push(file);
    }
  }
  return directories;
}

// node/resolve-package.ts
import path5 from "path";
import { createRequire } from "module";
var require2 = createRequire(import.meta.url);
function resolvePackage(name, root) {
  return path5.dirname(require2.resolve(`${name}/package.json`, root !== void 0 ? { paths: [root] } : void 0));
}

// node/get-extensions.ts
var findExtension = async (folder, filename) => {
  if (await fse3.exists(path6.join(folder, `${filename}.cjs`)))
    return `${filename}.cjs`;
  if (await fse3.exists(path6.join(folder, `${filename}.mjs`)))
    return `${filename}.mjs`;
  return `${filename}.js`;
};
async function resolvePackageExtensions(root, extensionNames) {
  const extensions = [];
  const local = extensionNames === void 0;
  if (extensionNames === void 0) {
    extensionNames = await listFolders(root);
    extensionNames = extensionNames.filter((name) => EXTENSION_NAME_REGEX.test(name));
  }
  for (const extensionName of extensionNames) {
    const extensionPath = local ? path6.join(root, extensionName) : resolvePackage(extensionName, root);
    const extensionManifest = await fse3.readJSON(path6.join(extensionPath, "package.json"));
    let parsedManifest;
    try {
      parsedManifest = ExtensionManifest.parse(extensionManifest);
    } catch (error) {
      throw new Error(`The extension manifest of "${extensionName}" is not valid.
${error}`);
    }
    const extensionOptions = parsedManifest[EXTENSION_PKG_KEY];
    if (extensionOptions.type === "bundle") {
      extensions.push({
        path: extensionPath,
        name: parsedManifest.name,
        version: parsedManifest.version,
        type: extensionOptions.type,
        entrypoint: {
          app: extensionOptions.path.app,
          api: extensionOptions.path.api
        },
        entries: extensionOptions.entries,
        host: extensionOptions.host,
        local
      });
    } else if (isTypeIn(extensionOptions, HYBRID_EXTENSION_TYPES2)) {
      extensions.push({
        path: extensionPath,
        name: parsedManifest.name,
        version: parsedManifest.version,
        type: extensionOptions.type,
        entrypoint: {
          app: extensionOptions.path.app,
          api: extensionOptions.path.api
        },
        host: extensionOptions.host,
        local
      });
    } else {
      extensions.push({
        path: extensionPath,
        name: parsedManifest.name,
        version: parsedManifest.version,
        type: extensionOptions.type,
        entrypoint: extensionOptions.path,
        host: extensionOptions.host,
        local
      });
    }
  }
  return extensions;
}
async function getPackageExtensions(root) {
  let pkg;
  try {
    pkg = await fse3.readJSON(path6.resolve(root, "package.json"));
  } catch {
    throw new Error("Current folder does not contain a package.json file");
  }
  const extensionNames = Object.keys(pkg.dependencies ?? {}).filter((dep) => EXTENSION_NAME_REGEX.test(dep));
  return resolvePackageExtensions(root, extensionNames);
}
async function getLocalExtensions(root) {
  const extensions = [];
  for (const extensionType of NESTED_EXTENSION_TYPES) {
    const typeDir = pluralize(extensionType);
    const typePath = path6.resolve(root, typeDir);
    try {
      const extensionNames = await listFolders(typePath);
      for (const extensionName of extensionNames) {
        const extensionPath = path6.join(typePath, extensionName);
        if (isIn(extensionType, HYBRID_EXTENSION_TYPES2)) {
          extensions.push({
            path: extensionPath,
            name: extensionName,
            type: extensionType,
            entrypoint: {
              app: await findExtension(extensionPath, "app"),
              api: await findExtension(extensionPath, "api")
            },
            local: true
          });
        } else {
          extensions.push({
            path: extensionPath,
            name: extensionName,
            type: extensionType,
            entrypoint: await findExtension(extensionPath, "index"),
            local: true
          });
        }
      }
    } catch (e) {
      throw new Error(`Extension folder "${typePath}" couldn't be opened`);
    }
  }
  return extensions;
}

// node/is-readable-stream.ts
var isReadableStream = (input) => {
  return input !== null && typeof input === "object" && typeof input.pipe === "function" && typeof input._read === "function" && typeof input._readableState === "object" && input.readable !== false;
};

// node/readable-stream-to-string.ts
var readableStreamToString = async (stream) => {
  const chunks = [];
  for await (const chunk of stream) {
    chunks.push(Buffer.from(chunk));
  }
  return Buffer.concat(chunks).toString("utf8");
};
export {
  depluralize,
  ensureExtensionDirs,
  findExtension,
  generateExtensionsEntrypoint,
  getLocalExtensions,
  getPackageExtensions,
  isIn,
  isReadableStream,
  isTypeIn,
  listFolders,
  pathToRelativeUrl,
  pluralize,
  readableStreamToString,
  resolvePackage,
  resolvePackageExtensions
};
